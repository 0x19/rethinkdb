#!/usr/bin/env python

from __future__ import print_function, division

import os
import sys
import itertools

def main():
    try:
        assets_root = sys.argv[1]
        assert os.path.isdir(assets_root)
    except:
        print("Error: First argument must be a directory", file=sys.stderr)
        sys.exit(1)

    # List all the files in assets_root

    assets = [
        os.path.relpath(os.path.join(root, path), assets_root)
        for root, __, paths in os.walk(assets_root)
        for path in paths
    ]

    # Write the encoded files and an index to stdout

    print(prelude)

    write_assets(assets_root, assets)

prelude = """
// Generated by scripts/compile-web-assets.py

#include <map>
#include <utility>
#include <string>
"""

def write_assets(asset_root, assets):

    print('std::map<std::string, const std::pair<const char *, size_t> > static_web_assets = {')
    for i, asset in enumerate(assets):

        print('    { ' + encode('/' + asset) + ', {', end='')

        data = open(os.path.join(asset_root, asset)).read()
        position = 0 # track the position to keep lines short
        trigraph = 0 # track consecutive question marks to avoid writing trigraphs
        prev_e = None # track the previous character to avoid tacking on hex digits

        for c in data:

            if position == 0:
                # start a new line
                print('\n      "', end='')
                position = 7
                trigraph = 0
                prev_e = None

            if trigraph >= 2 and c in "=/'()!<>-":
                # split a trigraph
                print('" "', end='')
                prev_e = None
                position += 3
                trigraph = 0
            elif c == '?':
                # count the amount of question marks
                trigraph += 1
            else:
                trigraph = 0

            e = encode_char(c, prev_e)
            prev_e = e
            print(e, end='')
            position += len(e)

            if position > 82 or c == '\n':
                # end a line if it gets too long and on newlines
                print('"', end='')
                position = 0

        if position != 0:
            print('"', end='')
        print(',')
        print('      ' + str(len(data)) + ' } },')

    print('};')

def encode(string):
    return ''.join(
        ['"'] +
        [encode_char(c) for c in string]
        + ['"']
    )

def encode_char(c, previous=None):
    avoid_hex = previous and previous[0] == '\\' and previous[1] in 'x0'
    n = ord(c)
    if c == '\n':
        return '\\n'
    if c == '\0':
        return '\\0'
    if c in '\\"':
        return '\\' + c
    elif 32 <= n and n < 127 and not (avoid_hex and c in '01234567890abcdefABCDEF'):
        return c
    else:
        return '\\x' + "%02x" % n

if __name__ == "__main__":
    main()
