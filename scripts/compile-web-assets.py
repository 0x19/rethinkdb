#!/usr/bin/env python

from __future__ import print_function, division

import os
import sys
import itertools

def main():
    try:
        assets_root = sys.argv[1]
        assert os.path.isdir(assets_root)
    except:
        print("Error: First argument must be a directory", file=sys.stderr)
        sys.exit(1)

    # List all the files in assets_root

    assets = [
        Asset(os.path.relpath(os.path.join(root, path), assets_root))
        for root, __, paths in os.walk(assets_root)
        for path in paths
    ]

    # Write the encoded files and an index to stdout

    print(prelude)

    write_assets(assets_root, assets)

    write_index(assets)

# An Asset describes a file and it's index inthe web_assets array
class Asset(object):
    def __init__(self, path):
        self.path = path
        self.index = None

prelude = """
// Generated by scripts/compile-web-assets.py

#include <string.h>
"""

# The generated get_web_assets function returns the content of an
# asset given its path
def write_index(assets):
    print('const char *get_web_asset(const char *path) {')
    print('    size_t length = strlen(path);')
    write_choice(assets, indent=1, min_length=0)
    print('    return NULL;')
    print('};')

# Generate a balanced static search tree for the given assets
# assuming length is at least min_length
def write_choice(assets, indent, min_length):
    assert len(assets) != 0:
    if len(assets) == 1:
        asset = assets[0]
        write(indent, 'if (!strcmp(path, ' + encode(asset.path) + ')) {')
        write(indent, '    return web_assets[' + str(asset.index) + '];')
        write(indent, '}')
    else:
        split = best_split(assets, min_length)
        write(indent, 'if (' + split.condition() + ') {')
        write_choice(split.left, indent + 1, min_length)
        write(indent, '} else {')
        write_choice(split.right, indent + 1, split.right_min_length or min_length)
        write(indent, '}')

# Find a split point that most closely divides the assets into two halves
def best_split(assets, min_length):
    current_split = gen_split_length(assets)
    for i in range(0, min_length):
        split = gen_split_char(assets, i)
        if split.rank() < current_split.rank():
            current_split = split
    return current_split

# Find a length that best divides the assets
def gen_split_length(assets):
    split = gen_split(assets, lambda asset: len(asset.path), 'length')
    split.right_min_length = split.split_val
    return split

# Find the value of a given character index that best divides the assets
def gen_split_char(assets, i):
    return gen_split(assets, lambda asset: asset.path[i], 'path[' + str(i)+ ']')

# Find the value of an arbitrary function that best divides the assets
def gen_split(assets, key, field):
    sorted_assets = sorted(assets, key=key)
    left = []
    current_rank = 1
    split_val = None
    for val, group in itertools.groupby(sorted_assets, key=key):
        group = list(group)
        new_rank = rank(len(left) + len(group), len(assets) - len(left) - len(group))
        if new_rank < current_rank:
            left += group
            current_rank = new_rank
        else:
            split_val = val
            break
    if split_val == None:
        return Split(field, key(sorted_assets[0]), [], assets)
    else:
        right = sorted_assets[len(left):]
        return Split(field, split_val, left, right)

# Calculate the rank of a given split. Ranges from 0 to 0.5. Lower is better
def rank(left_count, right_count):
    return abs(0.5 - left_count / (left_count + right_count))

# A Split contains a split point and all the assets to the left and right of it
# - field is a string describing the C++ value being compared
# - split_val is the value of that field for this split
# - left contains all the assets where the field is lesser than split_val
# - right contains all the assets where the field is greater than or equal to split_val
# - right_min_length is the minimum string size of the asset's path
class Split(object):
    def __init__(self, field, split_val, left, right, right_min_length=None):
        self.field = field
        self.split_val = split_val
        self.left = left
        self.right = right
        self.right_min_length = right_min_length

    def condition(self):
        if isinstance(self.split_val, str):
            split_val = "'" + self.split_val + "'"
        else:
            split_val = str(self.split_val)
        return self.field + " < " + split_val

    def rank(self):
        return rank(len(self.left), len(self.right))

    def __str__(self):
        return (
            "Split(field=" + str(self.field) +
            ", split_val=" + str(self.split_val) +
            ", left=" + str(map(lambda a: a.path, self.left)) +
            ", right=" + str(map(lambda a: a.path, self.right)) +
            ", right_min_length=" + str(self.right_min_length) +
            ")"
        )

def write(indent, line):
    print(indent * '    ' + line)

def write_assets(asset_root, assets):
    print('const char *web_assets[] = {')
    for i, asset in enumerate(assets):
        asset.index = i
        print('    // ' + asset.path, end='')
        data = open(os.path.join(asset_root, asset.path)).read()
        position = 0
        trigraph = 0
        prev_e = None
        for c in data:
            if position == 0:
                print()
                print('    "', end='')
                position = 5
                trigraph = 0
                prev_e = None
            if trigraph >= 2 and c in "=/'()!<>-":
                print('" "', end='')
                prev_e = None
                position += 3
                trigraph = 0
            elif c == '?':
                trigraph += 1
            else:
                trigraph = 0
            e = encode_char(c, prev_e)
            prev_e = e
            print(e, end='')
            position += len(e)
            if position > 82 or c == '\n':
                print('"', end='')
                position = 0
        if position != 0:
            print('",')
        else:
            print(',')
    print('    NULL')
    print('};')

def encode(string):
    return ''.join(
        ['"'] +
        [encode_char(c) for c in string]
        + ['"']
    )

def encode_char(c, previous=None):
    avoid_hex = previous and previous[0] == '\\' and previous[1] in 'x0'
    n = ord(c)
    if c == '\n':
        return '\\n'
    if c == '\0':
        return '\\0'
    if c in '\\"':
        return '\\' + c
    elif 32 <= n and n < 127 and not (avoid_hex and c in '01234567890abcdefABCDEF'):
        return c
    else:
        return '\\x' + "%02x" % n

if __name__ == "__main__":
    main()
