// Copyright 2010-2015 RethinkDB, all rights reserved.
#ifndef CLUSTERING_TABLE_RAFT_FOLLOWER_HPP_
#define CLUSTERING_TABLE_RAFT_FOLLOWER_HPP_

namespace table_raft {

/* The `follower_t` is responsible for executing the instructions contained in the
`contract_t`s in the `table_raft::state_t`. It constantly monitors the current Raft state
and compares the contracts in the Raft state against its "ongoings", which represent
activities it is currently performing. As contracts appear and disappear from the Raft
state, it creates, updates, and destroys ongoings to match. It also takes care of
forwarding the `contract_ack_t`s generated by the ongoings back to the `leader_t`. */

class follower_t {
public:
    follower_t(
        const server_id_t &server_id,
        raft_member_t<state_t> *raft,
        watchable_map_t<std::pair<server_id_t, branch_id_t>, primary_bcard_t>
            *other_broadcaster_bcards);

    watchable_map_t<std::pair<server_id_t, contract_id_t>, contract_ack_t> *get_acks() {
        return &ack_map;
    }

    watchable_map_t<std::pair<server_id_t, branch_id_t>, primary_bcard_t>
            *get_primary_bcards() {
        return &primary_map;
    }

private:
    /* When a contract changes, we sometimes want to create a new ongoing and we
    sometimes want to update an existing one. Specifically, we want to create a new
    ongoing when:
     * The region of the contract changes
     * This server's role in the contract (primary, secondary, or neither) changes
     * This server's role is a secondary but the primary or branch has changed
    We implement this by computing an `ongoing_key_t` based on each contract, using the
    `get_contract_key()` function. If the old and new contracts have the same
    `ongoing_key_t`, then we update the corresponding ongoing. But if they differ, then
    we delete the old ongoing and create a new one. */
    class ongoing_key_t {
    public:
        enum class role_t { primary, secondary, erase };
        region_t region;
        role_t role;
        server_id_t primary;
        branch_id_t branch;
        /* This is just so we can use it as a `std::set`/`std::map` key */
        bool operator<(const ongoing_key_t &k) const {
            return std::tie(region, role, primary, branch) <
                std::tie(k.region, k.role, k.primary, k.branch);
        }
    };

    /* The actual work of the ongoing--accepting queries from the user, performing
    backfills, etc.--is carried out by the three classes `primary_t`, `secondary_t`, and
    `erase_t`. `ongoing_data_t` is just a simple wrapper around those three classes. */
    class ongoing_data_t {
    public:
        contract_id_t contract_id;
        /* Exactly one of these will be non-empty; which one depends on the `role` of the
        key that this is stored under */
        scoped_ptr_t<primary_t> primary;
        scoped_ptr_t<secondary_t> secondary;
        scoped_ptr_t<erase_t> erase;
    };

    ongoing_key_t get_contract_key(const std::pair<region_t, contract_t> &pair);

    /* `on_raft_state_change()` is called whenever the Raft state changes. In response to
    the Raft state change, we want to delete existing ongoings and spawn new ones.
    However, deleting ongoings may block. So `on_raft_state_change()` spawns
    `update_coro()`. `update_coro()` calls `apply_read()` on the Raft state watchable and
    passes the result to `update()`. `update()` may spawn new ongoings, but it may not
    delete them, because that would block. Instead, it puts their regions in
    `to_delete_out`, and then `update_coro()` deletes them. */
    void on_raft_state_change();
    void update_coro(auto_drainer_t::lock_t);
    void update(const state_t &new_state, std::set<region_t> *to_delete_out);

    /* This will send `cid` and `ack` to the current leader. It also records them and
    automatically re-sends if the leader changes. It's called by the `primary_t`,
    `secondary_t`, or `erase_t` via a `std::function` that we give to them. It must not
    block. */
    void send_ack(const contract_id_t &cid, const contract_ack_t &ack);

    raft_member_t<state_t> *const raft;

    std::map<ongoing_key_t, ongoing_data_t> ongoings;
    bool update_coro_running;

    auto_drainer_t drainer;
    watchable_t<raft_member_t<state_t>::state_and_config_t>::subscription_t
        raft_state_subs;
};

} /* namespace table_raft */

#endif /* CLUSTERING_TABLE_RAFT_FOLLOWER_HPP_ */

