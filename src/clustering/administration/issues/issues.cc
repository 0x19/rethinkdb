// Copyright 2010-2014 RethinkDB, all rights reserved.
#include "clustering/administration/issues/issues.hpp"
#include "clustering/administration/datum_adapter.hpp"
#include "clustering/administration/admin_tracker.hpp"

issues_artificial_table_backend_t::issues_artificial_table_backend_t(
            const admin_tracker_t &_admin_tracker) :
    admin_tracker(_admin_tracker)
{ }

std::string issues_artificial_table_backend_t::get_primary_key_name() {
    return "id";
}

bool issues_artificial_table_backend_t::read_all_primary_keys(UNUSED signal_t *interruptor,
                                                              std::vector<ql::datum_t> *keys_out,
                                                              UNUSED std::string *error_out) {
    admin_tracker.issue_multiplexer.get_issue_ids(keys_out);
    return true;
}

bool issues_artificial_table_backend_t::read_row(ql::datum_t primary_key,
                                                 UNUSED signal_t *interruptor,
                                                 ql::datum_t *row_out,
                                                 UNUSED std::string *error_out) {
    uuid_u issue_id;
    std::string dummy_error;
    if (!convert_uuid_from_datum(primary_key, &issue_id, &dummy_error)) {
        *row_out = ql::datum_t();
    } else {
        admin_tracker.issue_multiplexer.get_issue(issue_id, row_out);
    }
    return true;
}

bool issues_artificial_table_backend_t::write_row(UNUSED ql::datum_t primary_key,
                                                  UNUSED bool pkey_was_autogenerated,
                                                  UNUSED ql::datum_t new_value,
                                                  UNUSED signal_t *interruptor,
                                                  std::string *error_out) {
    error_out->assign("Cannot write to this table.");
    return false;
}

