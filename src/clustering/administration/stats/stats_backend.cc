#include "clustering/administration/stats/stats_backend.hpp"

stats_artificial_table_backend_t::stats_artificial_table_backend_t(
        const clone_ptr_t<watchable_t<change_tracking_map_t<peer_id_t,
            cluster_directory_metadata_t> > >
                &_directory_view,
        server_name_client_t *_name_client,
        mailbox_manager_t *_mailbox_manager) :
    directory_view(_directory_view),
    name_client(_name_client),
    mailbox_manager(_mailbox_manager) { }

std::string stats_artificial_table_backend_t::get_primary_key_name() {
    return std::string("id");
}

void stats_artificial_table_backend_t::get_peer_stats(
        const peer_id_t &peer,
        const std::set<std::string> &filter,
        boost::optional<perfmon_result_t> *result_out,
        signal_t *interruptor) {
    // Loop up peer in directory - find get stats mailbox

    // Create response mailbox

    // Send request

    // On timeout - return without setting result
    
}

void stats_artificial_table_backend_t::perform_stats_request(
        const std::map<server_id_t, peer_id_t> &peers,
        const std::set<std::string> &filter,
        std::map<server_id_t, boost::optional<perfmon_result_t> > *results_out,
        signal_t *interruptor) {
    pmap(peers.size(),
        [&](int index) {
            auto const &peer_it = peers.begin() + index;
            run_stats_request(peer_it.second, filter,
                              &(*results_out)[peer_it.first], interruptor);
        });
}

bool stats_artificial_table_backend_t::read_all_rows_as_vector(
        signal_t *interruptor,
        std::vector<ql::datum_t> *rows_out,
        UNUSED std::string *error_out) {
    std::set<std::string> filter = stats_request_t::global_stats_filter();
    std::map<server_id_t, peer_id_t> peers = stats:request_t::all_peers(name_client);

    std::map<server_id_t, boost::optional<perfmon_result_t> > result_map;
    perform_stats_request(peers, filter, &result_map, interruptor);

    // Start building results
    std::set<server_id_t> servers;
    std::set<namespace_id_t> tables; // TODO: get from metadata - or loop and get from results...
    rows_out->clear();
    rows_out->push_back(cluster_stats_request_t().to_datum(result_map));

    for (auto const &pair : peers) {
        rows_out->push_back(server_stats_request_t(pair.first).to_datum(result_map));
    }
    
    for (auto const &t : tables) {
        rows_out->push_back(table_stats_request_t(t).to_datum(result_map));
    }

    for (auto const &pair : peers) {
        for (auto const &t : tables) {
            rows_out->push_back(
                table_server_stats_request_t(t, pair.first).to_datum(result_map));
        }
    }

    return results;
}

template <class T>
bool parse_stats_request(const ql::datum_t &info,
                         scoped_ptr_t<stats_request_t> *request_out,
                         std::string *error_out) {
    if (request_type.as_str() == T::get_name()) {
        if (!T::parse(info, request_out, error_out)) {
            return false;
        }
    }
    return true;
}

bool stats_artificial_table_backend_t::read_row(
        ql::datum_t primary_key,
        signal_t *interruptor,
        ql::datum_t *row_out,
        std::string *error_out) {
    // TODO: better error messages
    if (primary_key.get_type() != ql::datum_t::R_ARRAY) {
        *error_out = "A stats request needs to be an array.";
        return false;
    }
    if (primary_key.arr_size() == 0) {
        *error_out = "The stats request is empty."
        return false;
    }

    datum_t request_type = primary_key.get(0);
    if (request_type.get_type() != ql::datum_t::R_STRING) {
        *error_out = "The first element of a stats request must be a string.";
        return false;
    }

    scoped_ptr_t<stats_request_t> request;
    if (!parse_stats_request<cluster_stats_request_t>(info, &request, error_out) ||
        !parse_stats_request<table_stats_request_t>(info, &request, error_out) ||
        !parse_stats_request<server_stats_request_t>(info, &request, error_out) ||
        !parse_stats_request<table__serverstats_request_t>(info, &request, error_out)) {
        return false;
    }

    if (!request.has()) {
        *error_out = "Unknown stats request type.";
        return false;
    }

    std::map<server_id_t, peer_id_t> peers;
    std::map<server_id_t, boost::optional<perfmon_result_t> > results_map;
    if (!request->get_peers(name_client, &peers, error_out)) {
        return false;
    }

    perform_stats_request(peers, request->get_filter(), &results_map, interruptor);
    *row_out = request->to_datum(results_map);
    return true;
}

bool stats_artificial_table_backend_t::write_row(
        ql::datum_t primary_key,
        bool pkey_was_autogenerated,
        ql::datum_t *new_value_inout,
        signal_t *interruptor,
        std::string *error_out) {
    // TODO: error message
    *error_out = "Cannot write to the stats table."
    return false;
}

class stats_request_t {
public:
    static std::set<std::string> global_stats_filter() {
        return std::set<std::string>({ "query_engine/.*", ".*/serializers/.*" });
    }

    static std::map<server_id_t, peer_id_t> all_peers(
            server_name_client_t *name_client) const {
        return name_client->get_server_id_to_peer_id_map()->get();
    }

    std::set<std::string> get_filter() const = 0;

    bool get_peers(server_name_client_t &name_client,
                   std::map<server_id_t, peer_id_t> *peers_out,
                   std::string *error_out) const = 0;

    ql::datum_t to_datum(
        const std::map<server_id_t,
                       boost::optional<perfmon_result_t> > &results) const = 0;
};

class parsed_cluster_stats_t {
public:
    parsed_cluster_stats_t(
            const std::map<server_id_t, boost::optional<perfmon_result_t> > &stats) {
        for (auto const &serv_pair : stats) {
            server_stats_t *serv_stats = &servers[serv_pair.first];
            *serv_stats = { }

            if (!static_cast<bool>(serv_pair.second)) {
                serv_stats->responsive = false;
                continue;
            }

            r_sanity_check(serv_pair.second.get().is_map());
            for (auto const &perf_pair : *serv_pair.second.get().get_map()) {
                if (perf_pair.first == "query_engine") {
                    add_query_engine_stats(*perf_pair.second, serv_stats);
                } else if (is_uuid(perf_pair.first)) {
                    namespace_id_t table_id;
                    bool res = str_to_uuid(perf_pair.first, &table_id);
                    r_sanity_check(res);
                    add_table_stats(table_id, *perf_pair.second, serv_stats);
                }
            }
        }
    }

    void add_perfmon_value(const perfmon_result_t &perf,
                           const std::string &key,
                           double *value_out) {
        auto const &value_it = perf.get_map()->find(key);
        if (value_it != perf.get_map()->end()) {
            r_sanity_check(value_it.second.is_number());
            *value_out += value_it.second.get_number();   
        }
    }

    void add_shard_values(const perfmon_result_t &shard_perf,
                          table_stats_t *stats_out) {
        r_sanity_check(shard_perf.is_map());
        auto const &shard_it = shard_perf.get_map()->find("shard_0");
        // Loop over all shard perfmons - collect stats for the primary key
        while (shard_it.first.find("shard_") == 0) {
            r_sanity_check(shard_it.second->is_map());
            auto const &pkey_it = shard_it.second->get_map().find("btree-primary");
            if (pkey_it != shard_it.second->get_map().end()) {
                r_sanity_check(pkey_it.second->is_map());
                add_perfmon_value(*pkey_it.second, "keys_read", &stats_out->reads_per_sec);
                add_perfmon_value(*pkey_it.second, "keys_set", &stats_out->writes_per_sec);
                add_perfmon_value(*pkey_it.second, "total_keys_read", &stats_out->reads_total);
                add_perfmon_value(*pkey_it.second, "total_keys_read", &stats_out->reads_total);
            }
        }
    }

    void add_serializer_values(const perfmon_result_t &ser_perf,
                               table_stats_t *stats_out) {
        r_sanity_check(ser_perf.is_map());
        // TODO: implement after modifying the perfmons to be closer to the stats we want
    }

    void add_query_engine_stats(const perfmon_result_t &perf,
                                server_stats_t *stats_out) {
        r_sanity_check(perf.is_map());
        add_perfmon_value(perf, "queries_per_sec", &stats_out->query_per_sec);
        add_perfmon_value(perf, "queries_total", &stats_out->query_per_sec);
        add_perfmon_value(perf, "clients_connected", &stats_out->clients_connected);
    }

    void add_table_stats(const namespace_id_t &table_id,
                         const perfmon_result_t &perf,
                         server_stats_t *stats_out) {
        r_sanity_check(perf.is_map());
        auto const &sub_map_it = perf.get_map()->find("serializers");
        if (sub_map_it != perf.get_map()->end()) {
            found_table_ids.insert(table_id);
            table_stats_t *table_stats_out = &stats_out->tables[table_id];
            *table_stats_out = { };

            add_shard_values(*sub_map_it->second, table_stats_out);
            
            auto const &ser_map_it = sub_map_it.get_map()->find("serializer");
            if (ser_map_it != sub_map_it.get_map()->end()) {
                add_serializer_values(*ser_map_it->second, table_stats_out);
            }
        }
    }

    struct table_stats_t {
        table_query_stats_t() :
            reads_per_sec(0), reads_total(0), writes_per_sec(0), writes_total(0),
            cache_size(0), metadata_bytes(0), data_bytes(0), garbage_bytes(0),
            preallocated_bytes(0), read_bytes_per_sec(0), read_bytes_total(0),
            written_bytes_per_sec(0), written_bytes_total(0) { }

        double reads_per_sec;
        double reads_total;
        double writes_per_sec;
        double writes_total;
        double cache_size;
        double metadata_bytes;
        double data_bytes;
        double garbage_bytes;
        double preallocated_bytes;
        double read_bytes_per_sec;
        double read_bytes_total;
        double written_bytes_per_sec;
        double written_bytes_total;
    };

    struct server_stats_t {
        server_stats_t() :
            responsive(true), queries_per_sec(0), queries_total(0),
            client_connections(0) { }

        bool responsive;
        double queries_per_sec;
        double queries_total;
        double client_connections;

        std::map<namespace_id_t, table_stats_t> tables;
    };

    std::map<server_id_t, server_stats_t> servers;
    std::set<namespace_id_t> found_table_ids;
};

struct table_serializer_stats_t {
    table_serializer_stats_t() :
};

void parse_server_stats(const perfmon_result_t &stats,
                            server_stats_t *stats_out) {
    
}

void parse_table_query_stats(const perfmon_result_t &stats,
                                 table_query_stats_t *stats_out) {

}

void parse_table_serializer_stats(const perfmon_result_t &stats,
                                      table_serializer_stats_t *stats_out) {

}

class cluster_stats_request_t {
    static const char *cluster_request_type = "cluster";
public:
    static const char *get_name() const { return cluster_request_type; }
    static bool parse(const ql::datum_t &info,
                      scoped_ptr_t<stats_request_t> *request_out,
                      std::string *error_out) {
        r_sanity_check(info.get_type() == ql::datum_t::R_ARRAY);
        if (info.arr_size() != 1 || info.get(0).as_str() != cluster_request_type) {
            *error_out =
                strprintf("A '%s' stats request should have the format ['%s'].",
                          cluster_request_type, cluster_request_type);
            return false;
        }
        request_out->reset(new cluster_stats_request_t());
        return true;
    }

    cluster_stats_request_t() { }

    std::set<std::string> get_filter() const {
        return std::set<std::string>({ "query_engine/queries_per_sec",
                                       ".*/serializers/shard[0-9]+/keys_.*" });
    }

    bool get_peers(server_name_client_t &name_client,
                   std::map<server_id_t, peer_id_t> *peers_out,
                   std::string *error_out) const {
        *peers_out = all_peers(name_client);
        return true;
    }

    ql::datum_t to_datum(
            const std::map<server_id_t,
                           boost::optional<perfmon_result_t> > &results) const {
        server_stats_t server_stats;
        table_query_stats_t table_stats;

        for (auto const &pair : results) {

        }

        ql::datum_array_builder_t id_builder(ql::configured_limits_t::unlimited);
        id_builder.add(datum_t("cluster"));

        ql::datum_object_builder_t qe_builder;
        qe_builder.add("queries_per_sec", ql::datum_t(queries_per_sec));
        qe_builder.add("queries_per_sec", ql::datum_t(queries_per_sec));
        qe_builder.add("queries_per_sec", ql::datum_t(queries_per_sec));

        datum_object_builder_t builder;
        builder.overwrite("id", std::move(id_builder).to_datum());
        builder.overwrite("query_engine", std::move(qe_builder).to_datum());
        return std::move(builder).to_datum();
    }
};

class table_stats_request_t {
    static const char *table_request_type = "table";
public:
    static const char *get_name() const { return table_request_type; }
    static bool parse(const ql::datum_t &info,
                      scoped_ptr_t<stats_request_t> *request_out,
                      std::string *error_out) {
        r_sanity_check(info.get_type() == ql::datum_t::R_ARRAY);
        if (info.arr_size() != 1 || info.get(0).as_str() != table_request_type) {
            *error_out = strprintf("A '%s' stats request should have the format "
                                   "['%s', <TABLE_ID>].",
                                   table_request_type, table_request_type);
            return false;
        }

        namespace_id_t t;
        if (!convert_uuid_from_datum(info.get(1), &t, error_out)) {
            return false;
        }
        request_out->reset(new table_stats_request_t(t));
        return true;
    }

    table_stats_request_t(const namespace_id_t &_table_id) :
        table_id(_table_id) { }

    std::set<std::string> get_filter() const {
        return std::set<std::string>({ 
            uuid_to_str(table_id) + "/serializers/shard[0-9]+/keys_.*" });
    }

    bool get_peers(server_name_client_t &name_client,
                   std::map<server_id_t, peer_id_t> *peers_out,
                   std::string *error_out) const {
        *peers_out = all_peers(name_client);
        return true;
    }

    ql::datum_t to_datum(
            const std::map<server_id_t,
                           boost::optional<perfmon_result_t> > &results) const {
    }

private:
    const namespace_id_t table_id;
};

class server_stats_request_t {
    static const char *server_request_type = "server";
public:
    static const char *get_name() const { return server_request_type; }
    static bool parse(const ql::datum_t &info,
                      scoped_ptr_t<stats_request_t> *request_out,
                      std::string *error_out) {
        r_sanity_check(info.get_type() == ql::datum_t::R_ARRAY);
        if (request_out.arr_size() != 1) {
            *error_out = strprintf("A '%s' stats request should have the format "
                                   "['%s', <SERVER_ID>].",
                                   server_request_type, server_request_type);
            return false;
        }

        server_id_t s;
        if (!convert_uuid_from_datum(info.get(2), &s, error_out)) {
            return false;
        }
        request_out->reset(new server_stats_request_t(s));
        return true;
    }

    server_stats_request_t(const server_id_t &_server_id) :
        server_id(_server_id) { }

    std::set<std::string> get_filter() const {
        return std::set<std::string>({ "query_engine/.*",
                                       ".*/serializers/shard[0-9]+/keys_.*" });
    }

    bool get_peers(server_name_client_t &name_client,
                   std::map<server_id_t, peer_id_t> *peers_out,
                   std::string *error_out) const {

    }

    ql::datum_t to_datum(
            const std::map<server_id_t,
                           boost::optional<perfmon_result_t> > &results) const {
    }

private:
    const server_id_t server_id;
};

class table_server_stats_request_t {
    static const char *table_server_request_type = "table_server";
public:
    static const char *get_name() const { return table_server_request_type; }
    static bool parse(const ql::datum_t &info,
                      scoped_ptr_t<stats_request_t> *request_out,
                      std::string *error_out) {
        r_sanity_check(info.get_type() == ql::datum_t::R_ARRAY);
        if (info.arr_size() != 3 || info.get(0).as_str() != table_server_request_type) {
            *error_out = strprintf("A '%s' stats request should have the format "
                                   "['%s', <TABLE_ID>, <SERVER_ID>].",
                                   table_server_request_type, table_server_request_type);
            return false;
        }

        namespace_id_t t;
        server_id_t s;
        if (!convert_uuid_from_datum(info.get(1), &t, error_out)) {
            return false;
        }
        if (!convert_uuid_from_datum(info.get(2), &s, error_out)) {
            return false;
        }
        request_out->reset(new table_server_stats_request_t(t, s));
        return true;
    }

    table_server_stats_request_t(const namespace_id_t &_table_id,
                                 const server_id_t &_server_id) :
        table_id(_table_id), server_id(_server_id) { }

    std::set<std::string> get_filter() const {
        return std::set<std::string>({ uuid_to_str(table_id) + "/serializers/.*" });
    }

    bool get_peers(server_name_client_t &name_client,
                   std::map<server_id_t, peer_id_t> *peers_out,
                   std::string *error_out) const {

    }

    ql::datum_t to_datum(
            const std::map<server_id_t,
                           boost::optional<perfmon_result_t> > &results) const {
    }

private:
    const namespace_id_t table_id;
    const server_id_t server_id;
};

