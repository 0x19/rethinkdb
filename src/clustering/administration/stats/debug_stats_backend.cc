// Copyright 2010-2014 RethinkDB, all rights reserved.
#include "clustering/administration/stats/debug_stats_backend.hpp"

#include "clustering/administration/datum_adapter.hpp"
#include "clustering/administration/servers/name_client.hpp"
#include "clustering/administration/main/watchable_fields.hpp"

debug_stats_artificial_table_backend_t::debug_stats_artificial_table_backend_t(
        boost::shared_ptr<semilattice_readwrite_view_t<servers_semilattice_metadata_t> >
            _servers_sl_view,
        server_name_client_t *_name_client,
        watchable_map_t<peer_id_t, cluster_directory_metadata_t> *_directory_view,
        mailbox_manager_t *_mailbox_manager) :
    common_server_artificial_table_backend_t(_servers_sl_view, _name_client),
    directory_view(_directory_view),
    mailbox_manager(_mailbox_manager)
    { }

debug_stats_artificial_table_backend_t::~debug_stats_artificial_table_backend_t() {
    begin_changefeed_destruction();
}

bool debug_stats_artificial_table_backend_t::write_row(
        UNUSED ql::datum_t primary_key,
        UNUSED bool pkey_was_autogenerated,
        UNUSED ql::datum_t *new_value_inout,
        UNUSED signal_t *interruptor,
        std::string *error_out) {
    *error_out = "It's illegal to write to the `rethinkdb.debug_stats` table.";
    return false;
}


bool debug_stats_artificial_table_backend_t::format_row(
        name_string_t const & server_name,
        server_id_t const & server_id,
        UNUSED server_semilattice_metadata_t const & server,
        signal_t *interruptor,
        ql::datum_t *row_out,
        UNUSED std::string *error_out) {
    ql::datum_object_builder_t builder;
    builder.overwrite("name", convert_name_to_datum(server_name));
    builder.overwrite("id", convert_uuid_to_datum(server_id));

    ql::datum_t stats;
    std::string stats_error;
    if (stats_for_server(server_id, interruptor, &stats, &stats_error)) {
        builder.overwrite("stats", stats);
    } else {
        builder.overwrite("error", ql::datum_t(datum_string_t(stats_error)));
    }

    *row_out = std::move(builder).to_datum();
    return true;
}

bool debug_stats_artificial_table_backend_t::stats_for_server(
        const server_id_t &server_id,
        signal_t *interruptor,
        ql::datum_t *stats_out,
        std::string *error_out) {
    boost::optional<peer_id_t> peer_id =
        name_client->get_peer_id_for_server_id(server_id);
    if (!static_cast<bool>(peer_id)) {
        *error_out = "Server is not connected.";
        return false;
    }

    get_stats_mailbox_address_t request_addr;
    directory_view->read_key(*peer_id, [&](const cluster_directory_metadata_t *md) {
        if (md != nullptr) {
            request_addr = md->get_stats_mailbox_address;
        }
    });
    if (request_addr.is_nil()) {
        *error_out = "Server is not connected.";
        return false;
    }

    /* Make a filter that includes everything */
    std::set<std::vector<std::string> > filter;
    filter.insert(std::vector<stat_manager_t::stat_id_t>());

    return fetch_stats_from_server(
        mailbox_manager,
        request_addr,
        filter,
        interruptor,
        stats_out,
        error_out);
}

