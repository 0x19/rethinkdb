#!/usr/bin/env python

# test-issue-url: https://github.com/rethinkdb/rethinkdb/issues/1774
# test-issue-description: test that writes can still proceede while a table is sharded

import os, sys, threading, time, Queue

# import our testing common
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir, os.path.pardir, 'common')))
import driver, http_admin, utils

# -- constants

databaseName = 'test'
tableName = os.path.splitext(os.path.basename(__file__))[0]

# -- setup

utils.import_pyton_driver()
server = driver.Process()
connection = r.connect(host=server.host, port=server.driver_port)

# make sure we have a clean table with no shards

if databaseName not in r.db_list().run(connection):
	r.db_create(databaseName).run(connection)

try:
	r.table_create(tableName).run(connection)
except r.RqlRuntimeError:
	r.table_drop(tableName).run(connection)
	r.table_create(tableName).run(connection)

# -- run the test
	
def fillTable(server, tableName, databaseName, stopSignal, returnChannel):
	
	threadConn = r.connect(host=server.host, port=server.driver_port, db=databaseName)
	
	counter = 0
	while True:
		try:
			stopSignal.get_nowait()
			break
		except Queue.Empty: pass
		try:
			r.table(tableName).insert({'id':counter, 'data':counter}).run(threadConn)
			counter += 1
		except Exception, e:
			returnChannel.put(e)
		time.sleep(.01)
	returnChannel.put(counter)

stopSignal = Queue.Queue()
returnChannel = Queue.Queue()

# - start filling the table

fillThread = threading.Thread(target=fillTable, args=(server, tableName, databaseName, stopSignal, returnChannel))
fillThread.daemon = True
fillThread.start()
time.sleep(1) # give it a moment to have something

# - perform the shard

admin = http_admin.ClusterAccess(addresses=[(server.host, server.http_port)])
admin.add_table_shard(tableName, '4')
admin.wait_until_blueprint_satisfied(tableName, print_seconds=False)
time.sleep(1) # another second to add more data

# -- check for errors

stopSignal.put(1)
time.sleep(1)
server.check_and_stop()
recordsEntered = 0
errorCounter = 0
uniqueErrors = {}
while True:
	try:
		returnValue = returnChannel.get_nowait()
		if isinstance(returnValue, Exception):
			errorCounter += 1
			if str(returnValue) not in uniqueErrors:
				uniqueErrors[str(returnValue)] = 1
			else:
				uniqueErrors[str(returnValue)] += 1
		else:
			recordsEntered = returnValue
				
	except Queue.Empty: break

if errorCounter != 0:
	for errorMessage, errorCount in uniqueErrors.items():
		print('%s x %s' % (errorCount, errorMessage))
		print('Created %d records' % recordsEntered)
	sys.exit(1)

# -- TODO: check that everything made it to the database that we expected

# --

print('Test passed, created %d records' % recordsEntered)
